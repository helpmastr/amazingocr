<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AmazingSuite | Universal Converter</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="terminal.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/tesseract.js@v5.0.3/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/docx@8.2.3/build/index.js"></script>
</head>

<body class="terminal-body">
    <div class="terminal-container">
        <div class="terminal-window">
            <div class="terminal-header">
                <div class="window-controls">
                    <span class="control close" onclick="window.location.href='hub.html'"></span>
                    <span class="control minimize"></span>
                    <span class="control maximize"></span>
                </div>
                <div class="terminal-title">
                    <i data-lucide="refresh-cw" size="14"></i> af â€” universal-converter â€” v3.1
                </div>
            </div>

            <div class="terminal-content" style="min-height: 450px;">
                <!-- Step 1: Select Input Type -->
                <div id="step1-view">
                    <div style="margin-bottom: 25px;">
                        <h2 class="terminal-text-green">> SELECT_INPUT_TYPE</h2>
                        <p class="terminal-text-muted">Choose the type of file you want to convert.</p>
                    </div>
                    <div class="hub-grid" style="max-width: 600px; margin: 0 auto;">
                        <div class="hub-card" onclick="selectInputType('doc')">
                            <i data-lucide="file-text" size="28"></i>
                            <h4>Documents</h4>
                            <p>PDF</p>
                        </div>
                        <div class="hub-card" onclick="selectInputType('img')">
                            <i data-lucide="image" size="28"></i>
                            <h4>Images</h4>
                            <p>JPG, PNG, WebP, GIF, BMP</p>
                        </div>
                    </div>
                    <p class="terminal-text-muted" style="text-align: center; margin-top: 20px; font-size: 11px;">
                        ðŸ’¡ Video/Audio conversion requires server-side processing
                    </p>
                </div>

                <!-- Step 2: Upload File -->
                <div id="step2-view" style="display: none;">
                    <div style="margin-bottom: 20px;">
                        <span class="terminal-text-muted" style="font-size: 12px;">INPUT_TYPE:</span>
                        <span id="selected-type-label" class="terminal-text-green"
                            style="font-size: 12px; margin-left: 8px;">DOCUMENTS</span>
                        <button class="terminal-btn" style="padding: 4px 10px; font-size: 11px; margin-left: 15px;"
                            onclick="goToStep(1)">CHANGE</button>
                    </div>
                    <div id="dropzone" class="terminal-dropzone">
                        <i data-lucide="upload-cloud" size="48" class="terminal-text-blue"></i>
                        <h3 class="terminal-text-green" style="margin: 15px 0 5px;">> UPLOAD_FILE</h3>
                        <p class="terminal-text-muted" style="font-size: 12px;">Drop your file here or click to browse
                        </p>
                    </div>
                    <input type="file" id="file-input" style="display: none;">
                </div>

                <!-- Step 3: Select Output Format & OCR -->
                <div id="step3-view" style="display: none;">
                    <div style="margin-bottom: 20px;">
                        <span class="terminal-text-muted" style="font-size: 12px;">FILE:</span>
                        <span id="uploaded-file-label" class="terminal-text-green"
                            style="font-size: 12px; margin-left: 8px;">document.pdf</span>
                        <button class="terminal-btn" style="padding: 4px 10px; font-size: 11px; margin-left: 15px;"
                            onclick="goToStep(2)">CHANGE</button>
                    </div>

                    <div style="display: flex; flex-direction: column; gap: 20px; max-width: 400px; margin: 30px auto;">
                        <div>
                            <label class="terminal-text-muted"
                                style="font-size: 12px; display: block; margin-bottom: 8px;">OUTPUT_FORMAT:</label>
                            <select id="output-format" class="terminal-select" style="width: 100%; padding: 12px;">
                                <!-- Dynamically populated -->
                            </select>
                        </div>

                        <div id="ocr-option"
                            style="display: flex; align-items: center; gap: 12px; padding: 15px; background: rgba(255,255,255,0.03); border-radius: 8px; border: 1px solid rgba(255,255,255,0.08);">
                            <input type="checkbox" id="ocr-toggle"
                                style="width: 18px; height: 18px; accent-color: var(--terminal-text);">
                            <label for="ocr-toggle" class="terminal-text-muted"
                                style="font-size: 13px; cursor: pointer;">
                                <span class="terminal-text-green">FORCE_OCR</span> â€” Use AI to extract text from pixels
                            </label>
                        </div>

                        <button id="convert-btn" class="terminal-btn primary"
                            style="width: 100%; justify-content: center; padding: 14px;">
                            <i data-lucide="zap" size="16"></i> START_CONVERSION
                        </button>
                    </div>
                </div>

                <!-- Step 4: Processing -->
                <div id="step4-view" style="display: none; padding: 20px;">
                    <div style="display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 12px;">
                        <span id="status-label" class="terminal-text-green">PREPARING_BUFFERS...</span>
                        <span id="progress-percent" class="terminal-text-green">0%</span>
                    </div>
                    <div class="progress-container"
                        style="background: rgba(255,255,255,0.05); height: 8px; border-radius: 4px; overflow: hidden;">
                        <div id="progress-bar"
                            style="height: 100%; width: 0%; background: var(--terminal-text); box-shadow: 0 0 10px var(--terminal-text); transition: width 0.1s;">
                        </div>
                    </div>
                    <div id="processing-log" class="terminal-text-muted"
                        style="font-size: 11px; margin-top: 25px; height: 120px; overflow-y: auto; line-height: 1.6; border-left: 1px solid rgba(0,255,65,0.2); padding-left: 15px;">
                    </div>
                </div>

                <!-- Step 5: Results -->
                <div id="step5-view" style="display: none; text-align: center; padding: 40px 20px;">
                    <div class="terminal-text-green" style="margin-bottom: 25px; font-size: 18px; font-weight: 700;">
                        <i data-lucide="check-circle" size="24" style="vertical-align: middle; margin-right: 10px;"></i>
                        <span id="finish-message">CONVERSION_COMPLETE</span>
                    </div>
                    <div id="ocr-results" style="display: none; text-align: left; margin-bottom: 25px;">
                        <label class="terminal-text-muted" style="font-size: 11px;">EXTRACTED_TEXT:</label>
                        <textarea id="ocr-text" readonly class="terminal-input"
                            style="width: 100%; min-height: 150px; margin-top: 8px; resize: none; font-size: 12px;"></textarea>
                    </div>
                    <div class="terminal-button-group" style="justify-content: center;">
                        <button id="download-btn" class="terminal-btn primary">
                            <i data-lucide="download" size="14"></i> DOWNLOAD_RESULT
                        </button>
                        <button id="reset-btn" class="terminal-btn" onclick="location.reload()">
                            <i data-lucide="refresh-cw" size="14"></i> NEW_TASK
                        </button>
                    </div>
                </div>

                <div class="terminal-prompt-footer" style="margin-top: 20px; font-size: 12px; opacity: 0.5;">
                    <span class="terminal-text-blue">af@amazing-suite</span> <span class="terminal-text-muted">:~
                        $</span> <span class="cursor"
                        style="display: inline-block; width: 8px; height: 15px; background: #fff; vertical-align: middle;"></span>
                </div>
            </div>
        </div>
    </div>

    <!-- macOS Dock -->
    <div class="terminal-dock">
        <div class="dock-item" data-label="Home" onclick="window.location.href='index.html'">
            <i data-lucide="home"></i>
        </div>
        <div class="dock-item" data-label="Converter Hub" onclick="window.location.href='hub.html'">
            <i data-lucide="layout-grid"></i>
        </div>
        <div class="dock-item" data-label="OCR Engine" onclick="window.location.href='engine.html'">
            <i data-lucide="scan-text"></i>
        </div>
        <div class="dock-item" data-label="GitHub"
            onclick="window.open('https://github.com/helpmastr/amazingocr', '_blank')">
            <i data-lucide="github"></i>
        </div>
    </div>

    <script>
        // Configure pdf.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const INPUT_ACCEPT = {
            'doc': '.pdf',
            'img': '.jpg,.jpeg,.png,.webp,.gif,.bmp'
        };

        const INPUT_LABELS = {
            'doc': 'DOCUMENTS (PDF)',
            'img': 'IMAGES'
        };

        const ALL_OUTPUT_FORMATS = [
            { value: 'pdf', label: 'PDF (Document)', types: ['doc', 'img'] },
            { value: 'png', label: 'PNG (Image)', types: ['doc', 'img'] },
            { value: 'jpg', label: 'JPG (Image)', types: ['doc', 'img'] },
            { value: 'webp', label: 'WebP (Image)', types: ['doc', 'img'] },
            { value: 'txt', label: 'TXT (Text Extraction)', types: ['doc', 'img'] },
            { value: 'docx', label: 'DOCX (Word Document)', types: ['doc', 'img'] },
            { value: 'bmp', label: 'BMP (Image)', types: ['doc', 'img'] }
        ];

        let currentInputType = null;
        let uploadedFile = null;
        let convertedBlob = null;
        let convertedFileName = '';

        function selectInputType(type) {
            currentInputType = type;
            document.getElementById('selected-type-label').textContent = INPUT_LABELS[type];
            document.getElementById('file-input').accept = INPUT_ACCEPT[type];
            goToStep(2);
        }

        function goToStep(step) {
            document.getElementById('step1-view').style.display = step === 1 ? 'block' : 'none';
            document.getElementById('step2-view').style.display = step === 2 ? 'block' : 'none';
            document.getElementById('step3-view').style.display = step === 3 ? 'block' : 'none';
            document.getElementById('step4-view').style.display = step === 4 ? 'block' : 'none';
            document.getElementById('step5-view').style.display = step === 5 ? 'block' : 'none';
            lucide.createIcons();
        }

        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('file-input');

        dropzone.addEventListener('click', () => fileInput.click());
        dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('drag-over'); });
        dropzone.addEventListener('dragleave', () => dropzone.classList.remove('drag-over'));
        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) handleFileUpload(e.dataTransfer.files[0]);
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) handleFileUpload(e.target.files[0]);
        });

        function handleFileUpload(file) {
            uploadedFile = file;
            document.getElementById('uploaded-file-label').textContent = file.name;
            populateOutputFormats();
            goToStep(3);
        }

        function populateOutputFormats() {
            const select = document.getElementById('output-format');
            select.innerHTML = '';

            // Show all formats that support this input type
            ALL_OUTPUT_FORMATS.forEach(fmt => {
                const opt = document.createElement('option');
                opt.value = fmt.value;
                opt.textContent = fmt.label;
                select.appendChild(opt);
            });

            // Context-aware OCR toggle
            const ocrOption = document.getElementById('ocr-option');
            ocrOption.style.display = 'flex'; // Always show for flexibility
        }

        function updateProgress(percent, label) {
            document.getElementById('progress-bar').style.width = `${percent}%`;
            document.getElementById('progress-percent').textContent = `${Math.round(percent)}%`;
            document.getElementById('status-label').textContent = label;
        }

        function addLog(text) {
            const log = document.getElementById('processing-log');
            log.innerHTML += `<div>> ${text}</div>`;
            log.scrollTop = log.scrollHeight;
        }

        document.getElementById('convert-btn').addEventListener('click', startConversion);

        async function startConversion() {
            const outputFormat = document.getElementById('output-format').value;
            const forceOCR = document.getElementById('ocr-toggle').checked;

            goToStep(4);
            document.getElementById('processing-log').innerHTML = '';

            try {
                addLog('MOUNTING_FILESYSTEM...');
                updateProgress(5, 'MOUNTING_FILESYSTEM...');
                await sleep(200);

                addLog(`INPUT_FILE: ${uploadedFile.name}`);
                addLog(`OUTPUT_FORMAT: ${outputFormat.toUpperCase()}`);
                updateProgress(10, 'ANALYZING_INPUT...');
                await sleep(200);

                let result;

                if (currentInputType === 'img') {
                    if (outputFormat === 'pdf') {
                        result = await convertImageToPDF(uploadedFile);
                    } else if (outputFormat === 'txt') {
                        result = await runOCR(uploadedFile);
                    } else if (outputFormat === 'docx') {
                        const ocr = await runOCR(uploadedFile);
                        result = await generateDocx(ocr.ocrText, uploadedFile.name);
                    } else {
                        result = await convertImageFormat(uploadedFile, outputFormat);
                    }
                } else if (currentInputType === 'doc') {
                    if (outputFormat === 'txt') {
                        result = await extractTextFromPDF(uploadedFile, forceOCR);
                    } else if (outputFormat === 'docx') {
                        const extraction = await extractTextFromPDF(uploadedFile, forceOCR);
                        result = await generateDocx(extraction.text, uploadedFile.name);
                    } else if (outputFormat === 'pdf') {
                        result = await optimizePDF(uploadedFile);
                    } else {
                        result = await convertPDFToImages(uploadedFile, outputFormat, forceOCR);
                    }
                }

                convertedBlob = result.blob;
                convertedFileName = result.filename;

                updateProgress(100, 'CONVERSION_COMPLETE');
                addLog('CONVERSION_COMPLETE');
                await sleep(300);

                goToStep(5);
                document.getElementById('finish-message').textContent = `SUCCESS: CONVERTED_TO_${outputFormat.toUpperCase()}`;

                if (result.ocrText || result.text) {
                    document.getElementById('ocr-results').style.display = 'block';
                    document.getElementById('ocr-text').value = result.ocrText || result.text;
                }

                lucide.createIcons();

            } catch (err) {
                console.error(err);
                addLog(`ERROR: ${err.message}`);
                updateProgress(0, 'CONVERSION_FAILED');
                alert('An error occurred during processing: ' + err.message);
            }
        }

        // ==================== STABLE OCR HANDLER ====================

        async function runOCR(file) {
            addLog('INITIALIZING_OCR_ENGINE...');
            updateProgress(20, 'INITIALIZING_OCR_ENGINE...');

            const worker = await Tesseract.createWorker('eng', 1, {
                logger: m => {
                    if (m.status === 'recognizing text') {
                        const prog = 20 + (m.progress * 70);
                        updateProgress(prog, 'RECOGNIZING_TEXT...');
                    }
                }
            });

            try {
                addLog('LOADING_IMAGE_FOR_OCR...');
                const img = await loadImage(file);

                addLog('PERFORMING_RECOGNITION...');
                const { data: { text } } = await worker.recognize(img);

                await worker.terminate();

                addLog('OCR_DONE');
                const blob = new Blob([text], { type: 'text/plain' });
                const baseName = file.name.replace(/\.[^.]+$/, '');

                return { blob, filename: `${baseName}_ocr.txt`, ocrText: text };
            } catch (e) {
                await worker.terminate();
                throw e;
            }
        }

        // ==================== PDF TEXT EXTRACTION ====================

        async function extractTextFromPDF(file, forceOCR) {
            if (forceOCR) return await convertPDFToImages(file, 'txt', true);

            addLog('EXTRACTING_TEXT_LAYER...');
            updateProgress(30, 'EXTRACTING_TEXT_LAYER...');

            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let fullText = '';

            for (let i = 1; i <= pdf.numPages; i++) {
                addLog(`SCANNING_PAGE_${i}...`);
                const page = await pdf.getPage(i);
                const content = await page.getTextContent();
                const strings = content.items.map(item => item.str);
                fullText += `--- Page ${i} ---\n${strings.join(' ')}\n\n`;
                updateProgress(30 + (i / pdf.numPages * 60), `SCANNING_PAGE_${i}...`);
            }

            const blob = new Blob([fullText], { type: 'text/plain' });
            const baseName = file.name.replace(/\.[^.]+$/, '');
            return { blob, filename: `${baseName}_extracted.txt`, text: fullText };
        }

        // ==================== IMAGE CONVERSIONS ====================

        async function convertImageFormat(file, targetFormat) {
            addLog('LOADING_IMAGE...');
            updateProgress(20, 'LOADING_IMAGE...');

            const img = await loadImage(file);
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');

            if (targetFormat === 'jpg' || targetFormat === 'jpeg') {
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            ctx.drawImage(img, 0, 0);
            updateProgress(60, 'ENCODING...');

            const mimeMap = {
                'jpg': 'image/jpeg',
                'png': 'image/png',
                'webp': 'image/webp',
                'bmp': 'image/bmp'
            };

            const blob = await new Promise(resolve => canvas.toBlob(resolve, mimeMap[targetFormat] || 'image/png', 0.92));
            const baseName = file.name.replace(/\.[^.]+$/, '');

            return { blob, filename: `${baseName}_converted.${targetFormat}` };
        }

        async function convertImageToPDF(file) {
            addLog('PDF_GENERATION_START...');
            const pdfDoc = await PDFLib.PDFDocument.create();
            const imgBuffer = await file.arrayBuffer();

            let img;
            if (file.type === 'image/png') img = await pdfDoc.embedPng(imgBuffer);
            else if (file.type === 'image/jpeg' || file.type === 'image/jpg') img = await pdfDoc.embedJpg(imgBuffer);
            else {
                // For WebP/BMP, convert to JPG first via canvas
                addLog('TRANSCODING_BUFFER...');
                const loadedImg = await loadImage(file);
                const canvas = document.createElement('canvas');
                canvas.width = loadedImg.width;
                canvas.height = loadedImg.height;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(loadedImg, 0, 0);
                const jpgBlob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.9));
                img = await pdfDoc.embedJpg(await jpgBlob.arrayBuffer());
            }

            const page = pdfDoc.addPage([img.width, img.height]);
            page.drawImage(img, { x: 0, y: 0, width: img.width, height: img.height });

            const pdfBytes = await pdfDoc.save();
            return { blob: new Blob([pdfBytes], { type: 'application/pdf' }), filename: `${file.name.split('.')[0]}.pdf` };
        }

        // ==================== PDF TO IMAGES / OCR ====================

        async function convertPDFToImages(file, outputFormat, forceOCR) {
            addLog('PDF_INITIALIZE...');
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

            const zip = outputFormat !== 'txt' ? new JSZip() : null;
            let ocrFullText = '';

            const worker = forceOCR ? await Tesseract.createWorker('eng') : null;

            for (let i = 1; i <= pdf.numPages; i++) {
                addLog(`PROCESSING_PAGE_${i}...`);
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 2.0 });
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const ctx = canvas.getContext('2d');
                await page.render({ canvasContext: ctx, viewport }).promise;

                if (forceOCR) {
                    addLog(`OCR_RUNNING_P${i}...`);
                    const { data: { text } } = await worker.recognize(canvas);
                    ocrFullText += `--- Page ${i} ---\n${text}\n\n`;
                    if (outputFormat === 'txt') continue;
                }

                if (zip) {
                    const mime = outputFormat === 'jpg' ? 'image/jpeg' : 'image/png';
                    const blob = await new Promise(r => canvas.toBlob(r, mime, 0.9));
                    zip.file(`page_${i}.${outputFormat}`, blob);
                }

                updateProgress(10 + (i / pdf.numPages * 80), `PROCESSING_PAGE_${i}...`);
            }

            if (worker) await worker.terminate();

            const baseName = file.name.replace(/\.[^.]+$/, '');
            if (outputFormat === 'txt') {
                return { blob: new Blob([ocrFullText], { type: 'text/plain' }), filename: `${baseName}_ocr.txt`, text: ocrFullText };
            }

            if (ocrFullText) zip.file('ocr_results.txt', ocrFullText);
            const content = await zip.generateAsync({ type: 'blob' });
            return { blob: content, filename: `${baseName}_export.zip` };
        }

        // ==================== DOCX GENERATION ====================

        async function generateDocx(text, sourceFilename) {
            addLog('GENERATING_DOCX_STRUCTURE...');
            updateProgress(80, 'GENERATING_DOCX_STRUCTURE...');

            const doc = new docx.Document({
                sections: [{
                    properties: {},
                    children: text.split('\n').map(line => {
                        return new docx.Paragraph({
                            children: [new docx.TextRun(line)],
                        });
                    }),
                }],
            });

            addLog('PACKAGING_DOCX...');
            const blob = await docx.Packer.toBlob(doc);
            const baseName = sourceFilename.replace(/\.[^.]+$/, '');

            return { blob, filename: `${baseName}.docx`, text };
        }

        async function optimizePDF(file) {
            addLog('RE_SAVING_PDF...');
            const bytes = await file.arrayBuffer();
            const pdfDoc = await PDFLib.PDFDocument.load(bytes);
            const out = await pdfDoc.save();
            return { blob: new Blob([out], { type: 'application/pdf' }), filename: `optimized_${file.name}` };
        }

        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Failed to load image.'));
                img.src = URL.createObjectURL(file);
            });
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        document.getElementById('download-btn').addEventListener('click', () => {
            if (!convertedBlob) return;
            const url = URL.createObjectURL(convertedBlob);
            const a = document.createElement('a');
            a.href = url; a.download = convertedFileName;
            document.body.appendChild(a); a.click();
            document.body.removeChild(a); URL.revokeObjectURL(url);
        });

        lucide.createIcons();
    </script>
</body>

</html>